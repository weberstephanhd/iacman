#!/bin/bash -e

WSROOT="${IAC_DEPL_COMP}"
WSROOT="${WSROOT:-$(iac dir comp)}"
WSROOT="${WSROOT:-$SCRIPT_BASE/..}"

LSROOT="${IAC_LS_ROOT:-$(iac dir)}"

CONFIG_DIR="${IAC_DEPL_INST:-$WSROOT}"
STATE_DIR="${IAC_DEPL_STATE:-$WSROOT}"
COMP_DIR="${IAC_DEPL_COMP:-$WSROOT}"
WORK_DIR="${IAC_DEPL_GEN:-$WSROOT}"

GEN_DIR="$CONFIG_DIR/gen"

CMD="$(basename "$0")"

set -o pipefail

source "$(dirname "$(iac lib)")/modmgmt"

loadModule stdio
loadModule utils

fix_stemcell()
{
  if [ -z "$IAAS_TYPE" -o "$IAAS_TYPE" == openstack ]; then
    local id
    local version="$1"
    id="$(exec_bosh stemcells 2>/dev/null | _lookup_entry 3 "$version" 4)"
    if [ -z "$id" ]; then
      id="$(exec_bosh stemcells 2>/dev/null | _lookup_entry 3 "$version\\*" 4)"
    fi
    if [ -z "$id" ]; then
      Error "stemcell not found"
    fi
    info "fixing stemcell"
    glance --insecure image-update --property hw_rng_model=virtio $id >/dev/null || "echo stemcell could not be patched"
  fi
}

###############################
# blobstore cache
###############################

check_blob()
{
  if [ -n "$BLOBSTORE_URL" ]; then
    curl -If -k "$BLOBSTORE_URL/$1" >/dev/null 2>&1
  else
    return 1
  fi
}

upload_blob()
{
  if check_blob "$2"; then
    found "found blob $2"
  else
    info "uploading blob cache $2"
    swift --insecure \
          --os-auth-url "$BLOBSTORE_AUTH_URL" \
          --auth-version 3 \
          --os-project-id "$BLOBSTORE_TENANT_ID" \
          --os-project-domain-name "$BLOBSTORE_DOMAIN" \
          --os-user-domain-name "$BLOBSTORE_DOMAIN" \
          --os-username "$BLOBSTORE_USERNAME" \
          --os-password "$BLOBSTORE_PASSWORD" \
        upload --object-name "$2" "$BLOBSTORE_CONTAINER" "$1"
  fi
}

download_blob()
{
  wget --no-check-certificate -O $1 "$BLOBSTORE_URL/$2" 2>/dev/null
}

check_blob_access()
{
  local config="$(cd $LSROOT; get_root -f .lsblob)"
  if [ -n "$config" ]; then
    source "$config/.lsblob"
    if [ -z "$BLOBSTORE_URL" ]; then
      Error "no blob store cache URL configured"
    fi
  fi
}

###############################
# bosh
###############################

# $1: release
# $2: version
bosh_check_release()
{
  exec_bosh releases 2> /dev/null | filter_fields 1 2 | {
    while read r v; do
      v="${v%%\*}"
      if [ "$r" == "$1" -a "$v" == "$2" ]; then
        return 0
      fi
    done
    return 1
  }
}

# $1: stemcell
# $2: version
bosh_check_stemcell()
{
  exec_bosh stemcells 2>/dev/null | lookup_entry "$release" 3 | {
    while read v; do
      v="${v%%\*}"
      if [ "$v" == "$version" ]; then
        return 0
      fi
    done
    return 1
  }
}

###############################
# deployment handlers
###############################
# handlers
# contract are the variables:
#   gen
#   descriptor

# $1+: function call
_handle_stemcells()
{
  local release
  local version
  local url
  while read release; do
    found stemcell $release
    while read version; do
      url="https://bosh.io/d/stemcells/$release?v=$version"
      found "Found stemcell $release: $version @ $url"
      file="$gen/stemcells/$release-$version.tgz"
      if [ $# -gt 0 ]; then
        "$@"
      fi
    done < <(jq -r '.resource_pools[].stemcell|select(.name=="'$release'").version'<<<"$descriptor"| sort | uniq | ignore_value null) 
  done < <( jq -r ".resource_pools[].stemcell.name"<<<"$descriptor" | sort | uniq)
  found "actual stemcell version is $version"
  svers="$version"
}

# $1+: function call
_handle_releases()
{
  local release
  local version
  local ref
  local url
  while read release; do
    version="$(jq -r '.releases[]|select(.name=="'$release'").version'<<<"$descriptor"| ignore_value null)"
    url="$(jq -r '.releases[]|select(.name=="'$release'").url'<<<"$descriptor" | ignore_value null)"
    git="$(jq -r '.releases[]|select(.name=="'$release'").git'<<<"$descriptor" | ignore_value null)"
    ref="$(jq -r '.releases[]|select(.name=="'$release'").ref'<<<"$descriptor" | ignore_value null)"

    if [ -n "$url" ]; then
      found "Found release $release: $version @ $url"
    else
      if [ -n "$git" ]; then
        found "Found release $release: $version @ source: $git $ref"
      else
        warn "Found release $release: $version NO RELEASE LOCATION CONFIGURED"
      fi
    fi
    file="$gen/releases/$release-$version.tgz"
    if [ $# -gt 0 ]; then
      "$@"
    fi
  done < <( jq -r ".releases|map(.name)[]"<<<"$descriptor" )
}

#
# $1: manifest file
# $2+: title
_prepare_handler()
{
  if [ -n "$LSROOT" ]; then
    gen="$LSROOT/gen"
  else
    gen="$WSROOT/gen"
  fi
  mkdir -p "$gen/stemcells"
  mkdir -p "$gen/releases"
  mkdir -p "$gen/compiled"
  mkdir -p "$gen/deployments"

  descriptor="$(cat "$1" | yaml2json)"
  info "${@:2}"
}

##############
# prepare deployment
##############

_prepare_stemcell()
{
  if [ ! -f "$file" ]; then
    if check_blob "stemcells/$(basename "$file")"; then
      found "found in local blob store"
      download_blob $file "stemcells/$(basename "$file")"
    else
      found "downloading from the internet"
      wget "$url" -O "$file" 2>/dev/null
    fi
  fi
  if bosh_check_stemcell "$release" "$version"; then
    found "stemcell version $version already uploaded to bosh"
  else
    info "uploading stemcell $release version $version"
    exec_bosh upload stemcell --skip-if-exists "$file"
    fix_stemcell $version
  fi
}

_check_latest()
{
  if [ "$version" == latest ]; then
    info "version latest not supported for blob store"
    return 1
  fi
}

_prepare_release()
{
  (
    cd "$GEN_DIR"
    if ! bosh_check_release "$release" "$version"; then
      file="$gen/compiled/$release-$version-on-$os-stemcell-$svers.tgz"
      if [ ! -f "$file" ]; then
        if check_blob "$(compiled_blob_name)"; then
          found "found in local blob store"
          download_blob $file "$(compiled_blob_name)"
        fi
      fi
      if [ -f "$file" ]; then
        info "uploading compiled release for $os version $svers"
        exec_bosh upload release --skip-if-exists $file
      else
        info "no compiled release found"

        file="$gen/releases/$release-$version.tgz"
        if [ -f "$file" ]; then
          found "  found release in cache"
        else
          if check_blob "$(release_blob_name)"; then
            found "  found in local blob store"
            download_blob $file "$(release_blob_name)"
          else
            info "release $release $version not found in blob store"
          fi
        fi
        if [ ! -f "$file" ]; then
          if [ -n "$url" ]; then
            found "downloading from the internet"
            wget "$url" -O "$file" 2>/dev/null
          fi
        fi
        if [ ! -f "$file" ]; then
          if [ -n "$git" ]; then
            _build_release "$@"
          else
            info "no source url for release $release"
          fi
        fi

        if [ -f "$file" ]; then
          info "uploading release"
          exec_bosh upload release --skip-if-exists $file
        else
          Error "no release location configured for release $release/$version"
        fi
      fi
    else
      found "release $release version $version already uploaded to bosh"
    fi
  )
}

# $1 releasename
# $2 version
# $3 git url
get_release_sources()
{(
  local release=$1
  local version=$2
  local url=$3
  local ref=$4
  if [ -z "$ref" ]; then
    ref=master
  fi
  cd "$WSROOT"
  if [  -d ".releases/$release" ]; then
     if ! check_repo  ".releases/$release" "$url"; then
       info "repository changed for $release"
       rm -Rf  ".releases/$release"
     fi
  fi
  if [ ! -d ".releases/$release/.git" ]; then
    info "cloning $url"
    mkdir -p .releases
    git clone -b "$ref" "$url" ".releases/$release"  >/dev/null 2>&1
  else
   info "fetching $url"
    ( cd .releases/$release
      git fetch >/dev/null 2>&1
      git checkout "origin/$ref" >/dev/null 2>&1
    )
  fi
  ( cd .releases/$release
    cid="$( (git log --reverse --"format=%H" origin/master -- "releases/$release/$release-$version.yml"
             git log --reverse --"format=%H" origin/master -- "releases/$release-$version.yml") | head -1)"
    if [ -z "$cid" ]; then
      Error "version $version not found for $release"
    fi
    cur="$(git rev-parse HEAD)"
    if [ "$cur" == "$cid" ]; then
      info "version $version has been checkout into:"
      info " - $(pwd)"
    else
      info "checkout $cid for version $version"
      git checkout "$cid" >/dev/null 2>&1
    fi
  )
)}

release_blob_name()
{
  echo "releases/$release/$(basename "$file")"
}
compiled_blob_name()
{
  echo "compiled/$os-$svers/$release/$(basename "$file")"
}

_build_release()
{
  (
    info syncing sources for $release $version from "$git"
    get_release_sources $release $version "$git"
    cd "$WSROOT/.releases/$release"
    local base
    base=releases/$release
    if [ ! -d "$base" -a ! -h "$base" ]; then
      base=releases
    fi
    if [ ! -f "$base/$release-$version.tgz" ]; then
      info "rebuilding release"
      #git submodule update --init --recursive
      info bosh create release $base/$release-$version.yml --with-tarball --name $release
      bosh create release $base/$release-$version.yml --with-tarball --name $release
    fi
    if [ ! -f "$base/$release-$version.tgz" ]; then
      Error "cannot create intended release"
    fi
    cp $base/$release-$version.tgz "$file"
  )
}


# $1: manifest file
prepare_deployment()
{
  if [ -z "$(get_root -f .lsblob)" ]; then
    info "no blobstore configured"
  else
    check_blob_access
  fi

  local gen
  local descriptor
  local svers
  local os=ubuntu-trusty
  _prepare_handler "$1" "prepare deployment $1"

  if ! _handle_releases _check_latest 3>/dev/null; then
    info "version latest not supported"
    return 1
  fi
  if ! _handle_stemcells _prepare_stemcell; then
    return 1
  fi
  if ! _handle_releases _prepare_release; then
    return 1
  fi
}


##############
# bosh calls
##############
add_opt()
{
  local v="$(jq -r "$2" <<<"$ACCESS_INFO")"
  if [ "$v" != null ]; then
    BOSH_OPTS+=( "$1" "$v" )
    return
  fi
  return 1
}

exec_bosh()
{
  info bosh "${BOSH_OPTS[@]}" "$@"
  bosh "${BOSH_OPTS[@]}" "$@"
}

###############################
# main
###############################

if [ -n "$IAC_ACTION_CREATE_MANIFEST" ]; then
  "$IAC_ACTION_CREATE_MANIFEST" "$1" >"$GEN_DIR/manifest.yml"
else
  if [ !-f "$GEN_DIR/manifest.yml" ]; then
    Error "no deployment manifest found"
  fi
fi

ACCESS_INFO="$(get_yaml_path "$1" .bosh)"
if [ "$ACCESS_INFO" != null ]; then
  add_opt -u .local.username   || add_opt -u .username
  add_opt -p .local.password   || add_opt -p .password
  add_opt -t .local.target_url || add_opt -t .target_url
else
  ACCESS_INFO="no bosh info found"
fi 
BOSH_OPTS+=( -d "$GEN_DIR/manifest.yml" )
BOSH_OPTS+=( --no-color )

NAME="$(get_yaml_field "$GEN_DIR/manifest.yml" .name)"

if [ -z "$IAC_QUIET" ]; then
  echo "--> action $CMD: $NAME ($GEN_DIR/manifest.yml)"
fi
case "$CMD" in
  prepare) prepare_deployment "$GEN_DIR/manifest.yml";;
  bosh)    
           case "$2" in 
             vms)  if [ $# -eq 2 ]; then
                     exec_bosh vms "$NAME"
                   else
                     exec_bosh "${@:2}"
                   fi;;
             info) echo "$ACCESS_INFO";;
             *)    exec_bosh "${@:2}";;
           esac;;
  *)       exec_bosh "$CMD" "${@:2}"
esac

