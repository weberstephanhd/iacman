#!/bin/bash -e

SCRIPT_DIR=$(dirname $(readlink -f ${BASH_SOURCE[0]}))
source "$SCRIPT_DIR/../lib/iacman"

###########################################################################
# extensions
###########################################################################

EXT=~/.iac

if [ -n "$IAC_CONFIG" ]; then
  EXT="$IAC_CONFIG"
fi

scanExtensions "$EXT"

###########################################################################
# commands
###########################################################################

CMD_colors()
{
  color_red     "***   red   ***"
  color_yellow  "***  yellow ***"
  color_green   "***   green ***"
  color_blue    "***   blue  ***"
  color_magenta "*** magenta ***"
  color_cyan    "***   cyan  ***"
  color_dark    "***   dark  ***"
  color_light   "***  light  ***"
  found         "***  normal ***"
  bold          "***   bold  ***"
}

########################
# directories
CMD_directory()
{
  QUIET=X
  setupEnv

  if [ -z "$1" ]; then
    echo "$LROOT"
  else
    local n
    local type="$(resolve_shortcut "$1" landscape deployment template component module config)"
    case "$type" in
      deployment)
        cacheAll
        n="$(require_deplname)"
        echo "${deplDefs[$n]}";;
      template)
        cacheAll
        n="$(require_tmplname)"
        echo "${tmplDefs[$n]}";;
      state)
        cacheAll
        n="$(require_deplname)"
        get_state_dir "$n";;
      gen)
        cacheAll
        n="$(require_deplname)"
        get_instance_gen_dir "$n";;
      component)
        n="$(get_default_deplname)"
        if [ -z "$n" ]; then
          if [ -n "$CROOT" ]; then
            echo "$CROOT"
          else
            Error "not in a deplyoment or component"
          fi
        else
          cacheAll
          get_component_dir "$n"
        fi;;
      module) echo "$MROOT";;
      landscape) echo "$LROOT";;
      config)
        cacheAll
        n="$(require_deplname)"
        if [ -z "$n" ]; then
          Error "no deployment found"
        fi
        get_instance_dir "$n";;
      *) Error "invalid directory name '$1'";;
    esac
  fi
}

########################
# call editor

# $1: file
# $2: dir
check_file_in_dir()
{
  (
    cd "$2"
    [ -f "$1" ]
  )
}

HELP_vi()
{
  echo "vi <filename>:call editor for file in deployment folder"
  echo ":the filename might be flat or hierarchical,"
  echo ":it is found below a deployment folder or"
  echo ":its gen folder"
}

CMD_vi()
{
  setupEnv
  cacheAll

  local t
  local n
  local i
  local c
  n="$(require_deplname)"
  t="$(require_deployment "$n")"
  i="$(get_instance_dir "$n")"
  c="$(get_component_dir "$n")"

  if [ -n "$1" ]; then
    if check_file_in_dir "$1" "$i"; then
      cd "$i"
      exec vi "$1"
    fi
    if check_file_in_dir "$1" "gen/$i"; then
      cd "$i"
      exec vi "gen/$1"
    fi
    if check_file_in_dir "$1" "$c"; then
      cd "$c"
      exec vi "$1"
    fi
  fi
  cd "$i"
  exec vi "$@"
}

########################
# lib
HELP_lib()
{
  echo "lib:echo the library path for sourcing the iac"
  echo " :library"
}

CMD_lib()
{
  echo "$(dirname "$SCRIPT_DIR")/lib/iacman"
}

########################
# ls
CMD_ls()
{
  local i
  case "$1" in
    -a|-d|-c|-t) 
      setupEnv
      cacheAll
      case "$1" in
        -a)
          log confirm "active deployments"
          for i in "${!deplDefs[@]}"; do
            if [ -n "${deplActive["$i"]}" ]; then
              echo "$i"
            fi
          done;;
        -d)
          log confirm "deployments"
          for i in "${!deplDefs[@]}"; do
            echo "$i"
          done;;
        -t)
          log confirm "templates"
          for i in "${!tmplDefs[@]}"; do
            echo "$i"
          done;;
        -c)
          log confirm "components"
          for i in "${!compDefs[@]}"; do
            echo "$i"
          done;;
      esac
      return;;
  esac
  if [ -z "$1" ]; then
    setupEnv
    scan -p "$LROOT"
  else
    cd "$1"
    setupEnv
    if [ -n "$CROOT" ]; then
      found "component $CNAME"
    fi
    if [ -n "$TROOT" ]; then
      found "template $TNAME"
    fi
    if [ -n "$DROOT" ]; then
      if [ -f "$DROOT/$FILE_DEPLOYMENT" ]; then
        found "deployment definition for $DNAME"
      else
        found "deployment config for $DNAME"
      fi
    fi
    if [ -n "$MROOT" ]; then
      if [ -z "$MNAME" ]; then
        found "landscape root"
      else
        found "module $MNAME"
      fi
      if [ -z "$CROOT" -a -z "$DROOT" ]; then
        scan -p "$MROOT"
      fi
    fi
  fi
}

########################
# show

# $1: name
# $2: key
# $3: title
# [$4]: filter command
_showHashedList()
{
  local a=( )
  _get_array a "$1" "$2" || true
  if [ ${#a[@]} -gt 0 ]; then
    title "  ${3}:"
    for i in "${a[@]}"; do
      if [ -n "$4" ]; then
        found "  - $($4 "$i")"
      else
        found "  - $i"
      fi
    done
  fi
}

_showHashedDeplList()
{
  local a=( )
  _get_array a "$1" "$2" || true
  if [ ${#a[@]} -gt 0 ]; then
    color_title "  ${3}:"
    for i in "${a[@]}"; do
      p="${deplDefs[$i]}"
      if [ -z "$p" ]; then
        color_warn "  - $i (undefined)"
      else
        color_found "  - $i ($(norm_path "$p"))"
      fi
    done | column -t | sed 's/^/  /'
  fi
}

_showHashedDeplLabels()
{
  local l
  declare -A a
  declare -A a
  _get_hash a "$1" "$2" || true
  if [ ${#a[@]} -gt 0 ]; then
    color_title "  ${3}:"
    for l in "${!a[@]}"; do
      local d="${a["$l"]}"
      local p="${deplDefs[$d]}"
      if [ -z "$p" ]; then
        color_warn "  - $l: $d (undefined)"
      else
        color_found "  - $l: $d ($(norm_path "$p"))"
      fi
    done | column -t | sed 's/^/  /'
  fi
}


# $1: name
# $2: type key
_showElement()
{
  local p
  local t
  local c

  eval p="\"\${${2}Defs[\"\$1\"]}\""

  color_found "  path: $(norm_path "$p")"

  _showHashedList "$1" ${2}DCtxs "descriptor context"
  _showHashedList "$1" ${2}DStubs "descriptor stubs" norm_path

  eval t="\"\${${2}Tmpls[\"\$1\"]}\""
  if [ -n "$t" ]; then
    color_title "  templates:" 
  fi
  while [ -n "$t" ]; do
    p="${tmplDefs["$t"]}"
    if [ -z "$p" ]; then
      color_warn "  - $t (undefined)"
    else
      color_found "  - $t ($(norm_path "$p"))"
    fi
    t="${tmplTmpls[$t]}"
  done

  eval c="\"\${${2}Comps[\"\$1\"]}\""
  if [ -z "$c" ]; then
    color_warn "no component declared"
  else
    p="${compDefs[$c]}"
    if [ -z "$p" ]; then
      color_warn "  component: $c (undefined)"
    else
      color_found "  component: $c ($(norm_path "$p"))"
    fi
    _showHashedList "$c" compCtxs "component context"
  fi

  _showHashedDeplList "$1" ${2}Reqs "requires"
  if ! _equals_array "$1" ${2}Reqs ${2}EReqs; then
    _showHashedDeplList "$1" ${2}EReqs "requires (effective)"
  fi
  _showHashedDeplList "$1" ${2}Glmps "glimpses"
  if ! _equals_array "$1" ${2}Glmps ${2}EGlmps; then
    _showHashedDeplList "$1" ${2}EGlmps "glimpses (effective)"
  fi

  _showHashedList "$1" ${2}Incls " includes"

  _showHashedDeplLabels "$1" ${2}Labels "effective imports"
  _showHashedList "$1" ${2}Ctxs "context"
  if ! _equals_array "$1" ${2}Ctxs ${2}ECtxs; then
    _showHashedList "$1" ${2}ECtxs "effective context"
  fi
}

showTemplate()
{
  local i
  local a=( )
  local p="${tmplDefs[$1]}"
  if [ -z "$p" ]; then
    Error "deployment template $1 not found"
  fi
  color_confirm "deployment template $1"
  _showElement "$1" tmpl
}

showDeployment()
{
  local i
  local a=( )
  local p="${deplDefs[$1]}"
  if [ -z "$p" ]; then
    Error "deployment $1 not found"
  fi
  if [ -n "$2" ]; then
    if [ -f "$2/$FILE_DEPLOYMENT" ]; then
      color_confirm "deployment definition $1"
    else
      color_confirm "deployment configuration $1"
    fi
  else
    color_confirm "deployment definition $1"
  fi
  if [ ! ${deplActive[$1]:+set} ]; then
    color_red "  INACTIVE"
  fi
  _showHashedList "$1" deplInfos "configurations" norm_path
  _showElement "$1" depl
  _showHashedList "$1" deplStubs "effective stubs" norm_path
}


showComponent()
{
  local i
  local p="${compDefs[$1]}"
  if [ -z "$p" ]; then
    Error "component $1 not found"
  fi
  color_confirm "component $1"
  color_found "  path: $(norm_path "$p")"
  color_found "  type: ${compTypes[$1]}"
  color_found "  manifest: ${compMFs[$1]}"
  
  _get_array a "$1" compCtxs || true
  if [ ${#a[@]} -gt 0 ]; then
    color_title "  context:"
    for i in "${a[@]}"; do
      color_found "  - $i"
    done
  fi

  get_component_deployments "$1" | (
    local f=
    while IFS='' read -r d; do
      color_found "  - $d ($(norm_path "${deplDefs[$d]}"))"
    done | column -t | while IFS='' read -r d; do
      if [ -z "$f" ]; then
        color_title "deployments"
        f=X
      fi
      echo "$d"
    done | sed 's/^/  /'
  )
}

showModule()
{
  local p="${modDefs[$1]}"
  if [ -z "$p" ]; then
    Error "module $1 not found"
  fi
  listModule "$p"
}

listModule()
{
  (
    declare -A modDefs     # module definition locations
    declare -A deplDefs    # deployment definition locations
    declare -A deplComps   # deployment component for deployment
    declare -A deplActive  # active flag for deployment
    declare -A tmplDefs    # template defintions
    declare -A tmplComps   # component for template
    declare -A compDefs    # component defintions
    scan -p "$p"
  )
}

CMD_show()
{
  setupEnv
  cacheAll

  if [ $# -eq 0 ]; then
    if [ -n "$CROOT" ]; then
      showComponent "$CNAME"
    fi
    if [ -n "$TROOT" ]; then
      showTemplate "$TNAME"
    fi
    if [ -n "$DROOT" ]; then
      showDeployment "$DNAME" "$DROOT"
    fi
    if [ -z "$CROOT" -a -z "$TROOT" -a -z "$DROOT" -a -n "$MROOT" ]; then
      if [ -z "$MNAME" ]; then
        found "landscape root"
      else
        found "module $MNAME"
      fi
      listModule "$MROOT"
    fi
  else
    if [ $# -eq 2 ]; then
      local type="$(resolve_shortcut "$1" deployment template component module)"
      case "$type" in 
        deployment)
          showDeployment "$2";;
        template)
          showTemplate "$2";;
        component)
          showComponent "$2";;
        module)
          showModule "$2";;
        *) Error "illegal element type $1";;
      esac
    else
      local p="${deplDefs[$1]}"
      if [ -n "$p" ]; then
        showDeployment "$1"
      else 
        p="${compDefs[$1]}"
        if [ -n "$p" ]; then
          showComponent "$1"
        else
          p="${modDefs[$1]}"
          if [ -n "$p" ]; then
            showModule "$1"
          else
            Error "no element with name '$1' found"
          fi
        fi
      fi
    fi
  fi
}

########################
# show dependency closure

CMD_closure()
{
  setupEnv
  cacheAll

  local t
  local n
  n="$(require_deplname "$1")"
  t="$(require_deployment "$n")"
  log info "generating dependency closure for $n"

  if has_cycle required "$n"; then
    warn "deployment cycle detected"
  fi
  local a=( )
  if ! import_closure a "$n"; then
    list_array __missing dump_err
    return 1
  else
    list_array a
  fi
}

HELP_order()
{
  echo "order [<deployment name>|all]:list deployments by deployment order"
}

CMD_order()
{
  setupEnv
  cacheAll

  local t
  local n
  local a=( )
  local depls=( )

  if [ "$1" == all ]; then
    log info "generate deployment order"
    depls=( )
  else
    n="$(require_deplname "$1")"
    t="$(require_deployment "$n")"
    log info "generating deployment order for $n"

    if has_cycle required "$n"; then
      warn "deployment cycle detected"
    fi
    depls=( "$n" )
  fi

  if ! deploy_order a "${depls[@]}"; then
    list_array __missing dump_err
    return 1
  else
    list_array a
  fi
}

########################
# generate imports

CMD_imports()
{
  setupEnv
  cacheAll

  local t
  local n
  n="$(require_deplname "$1")"
  t="$(require_deployment "$n")"
  mkdir -p "$TMP"
  log info "generating imports for $n"
  generate_imports "$n" "$TMP"
}

########################
# generate context

CMD_context()
{
  setupEnv
  cacheAll

  local t
  local n
  n="$(require_deplname "$1")"
  t="$(require_deployment "$n")"
  mkdir -p "$TMP"
  if [ ${opts[local]+set} ]; then
    log info "generating context for $n (local)"
    __generate_context "$n" "$(get_instance_gen_dir "$n")"
  else
    log info "generating context for $n"
    generate_context "$n" "$TMP"
  fi
}

########################
# generate exports

CMD_exports()
{
  setupEnv
  cacheAll

  local t
  local n
  n="$(require_deplname "$1")"
  t="$(require_deployment "$n")"
  mkdir -p "$TMP"
  if [ ${opts[local]+set} ]; then
    log info "generating exports for $n (local)"
    __generate_exports "$n" "$(get_instance_gen_dir "$n")"
  else
    log info "generating exports for $n"
    generate_exports "$n" "$TMP"
  fi
}

########################
# generate manifest

CMD_manifest()
{
  setupEnv
  cacheAll

  local t
  local n
  n="$(require_deplname "$1")"
  t="$(require_deployment "$n")"
  mkdir -p "$TMP"
  if [ ${opts[local]+set} ]; then
    log info "generating manifest for $n (local)"
    __generate_manifest "$n" "$(get_instance_gen_dir "$n")"
  else
    log info "generating manifest for $n"
    generate_manifest "$n" "$TMP"
  fi
}

########################
# action execution

exec_action()
{
  setupEnv
  cacheAll
  _exec_action "$@"
}

_exec_action()
{
  local n
  local t
  n="$(deplname_from_args)"
  t="$(require_deployment "$n")"
  local gen="$(get_instance_gen_dir "$n")"
  if [ ${opts[local]+set} ]; then
    __generate_context "$n" "$gen"
  else
    generate_context "$n" "$TMP"
  fi
  execute_action "$n" "$1" "$gen/$GEN_CTX" "${@:2}"
}

CMD_action()
{
  if [ $# -lt 1 ]; then
    Error "${ERRCTX}${ERRCTX:+: }action name missing"
  fi
  exec_action "$@"
}

CMD_prepare()
{
  exec_action prepare "$@"
}

CMD_plan()
{
  exec_action plan "$@"
}

CMD_deploy()
{
  exec_action deploy "$@"
}

CMD_clean()
{
  setupEnv
  cacheAll
  local d

  if [ "$1" == all ]; then
    for d in "${!deplDefs[@]}"; do
      cleanup_deployment "$d"
    done
  else
    d="$(require_deplname "$1")"
    cleanup_deployment "$d"
  fi
}

# missing command handler
# $1: prefix of missing command function
# $2: command name
# $3+: command arguments
handle_action_command()
{
  setupEnv
  cacheAll
  loadExtensions
  if [ "$(type -t "$1$2")" == "function" ]; then
    $1$2 "${@:3}"
  else
    _exec_action "$2" "${@:3}"
  fi
}

###########################################################################
# utils
###########################################################################

list_commands()
{
  QUIET=X
  { _setupEnv && cacheAll; } || true
  known=( colors ls directory show closure imports context clean action prepare manifest exports deploy plan )
  loadExtensions
  declare -F | while read a b c d; do
    echo "$c"
  done | grep -e "^CMD_" | sed -e 's/^CMD_\(.*\)/\1/' | sort | while read a; do
    if ! contains "$a" "${known[@]}"; then
      if [ "$(type -t "HELP_$a")" == "function" ]; then
        eval HELP_$a
      else
        echo "$a:"
      fi
    fi
  done
}

###########################################################################
# link evaluation
###########################################################################

link=$(basename "$0")
if [ "$link" == iac ]; then
  cmd="iac"
else
  cmd=${link##iac}
fi

###########################################################################
# help
###########################################################################

if [ \( "$cmd" == iac -a -z "$1" \) -o "$1" == help -o "$1" == "--help" -o "$1" == "-help" ]; then
  help="$(list_commands)"
  found lsman - landscape management tool
  title "iac [<options>] <command> [<args>]"
  found
  found "Options:"
  found "  -q         quiet"
  found "  -a         generate for all deployments used"
  found "  -k         keep temporary generation data"
  found "  -l         local action call reusing pregenerated imports"
  found "  -S         show spiff calls"
  found "  -D         debug"
  found "  -d <name>  deployment name"
  found
  found "Commands:"
  found "  ls [<dir>]                     list landscape/module structure"
  found "  directory [deployment|template|component|module|landscape|config"]
  found "                                 show dedicted derived directory"
  found "                                 based on current working directory"
  found "  show [[component|template|deployment|module] <name>]"
  found "                                 details for dedicated element"
  found "  closure [<name>]               dependency closure"
  found "  imports                        generate imports"
  found "  context                        generate context"
  found "  clean                          cleanup generation folders"
  echo "$help" | while IFS=":" read -r a b; do
    printf -v txt "%-30s %s" "$a" "$b"
    if [ -n "$a" ]; then
      found "  $txt"
    else
      info  "  $txt"
    fi
  done

  found 
  found "Handle actions provided by component for deployments:"
  found "  action <name>  <args>         execute arbitrary action for deployment"
  found "  prepare                       execute prepare action"
  found "  manifest                      generate manifest"
  info  "                                context provided by iac and passed as argument"
  info  "                                this action is defaulted by using"
  info  "                                the context as manifest."
  found "  exports                       generate exports"
  info  "                                context provided by iac and passed as argument"
  info  "                                this action is defaulted by generating"
  info  "                                the manifest and reading the exports section."
  found "  deploy                        execute deploy action"
  found "  plan                          execute plan action"
  exit 0
fi

###########################################################################
# main
###########################################################################
declare -g -A opts
declare -g -A params
params=( [a]=all [k]=keep [n]=no-colors [l]=local [S]=spiff [q]=quiet [D]=debug [d]="=deployment" )
OPT_parse_options params opts "$@"
shift $(( _cnt - 1 ))

if [ "$cmd" == iac ]; then
  cmd="$1"
  if [ $# -gt 0 ]; then
    shift
  fi
fi

if [ ${opts[quiet]+set} ]; then
  QUIET=X
fi
if [ ${opts[debug]+set} ]; then
  DEBUG[$location]=X
fi
if [ ${opts[no-colors]+set} ]; then
  export color_mode=
fi


CMDS=( show closure order imports context exports manifest action ls prepare plan deploy lib vi directory clean colors )
cmd="$(resolve_shortcut "$cmd" "${CMDS[@]}")"

execute_command --invalid=handle_action_command "$cmd" CMD_ "${CMDS[*]}" "$@"

