
###########################################################################
###########################################################################
# boshman main module
###########################################################################
###########################################################################

IAC_LIB="$(dirname $(readlink -f ${BASH_SOURCE[0]}))"
IAC_BASE="$(dirname "$IAC_LIB")"
IAC_PLUGINS="$IAC_BASE/plugins"
source "$IAC_LIB/modmgmt"

set -o pipefail

loadModule stdio
loadModule utils
loadModule data
loadModule opts


###########################################################################
# utils
###########################################################################

QUIET=
TMP=/tmp/iacman$$
trap cleanup 2 ERR EXIT

cleanup()
{
  #info "cleanup $TMP"
  if [ -d "$TMP"  ] && [ ${opts[keep]+set} ]; then
    confirm "generation data kept in '$TMP'"
  else
    rm -Rf "$TMP"
  fi
}

################
# optional execution of log command
# $*: command
log()
{
  if [ -z "$QUIET" ]; then
    "$@"
  fi
}

check_opts()
{
  local o
  for o; do
    if [ ${opts[$o]+set} ]; then
      return 0
    fi
  done
  return 1
}

uniq()
{
  local a=( )
  for e; do
    if ! contains "$e" "${a[@]}"; then
      echo "$e"
      a+=( "$e" )
    fi
  done
}

p_land()
{
  color_green "$@"
}
p_mod()
{
  color_red "$@"
}
p_comp()
{
  color_magenta "$@"
}
p_depldef()
{
  color_blue "$@"
}
p_deplcfg()
{
  color_cyan "$@"
}
p_plugin()
{
  color_cyan "$@"
}
p_cfg()
{
  color_dark "$@"
}
p_tmpldef()
{
  color_light "$@"
}


###########################################################################
# command line utils
###########################################################################

declare -gA opts

require_deplname()
{
  if [ -n "$1" ]; then
    echo "$1"
  else
    require_default_deplname deployment name required
  fi
}

require_tmplname()
{
  if [ -n "$1" ]; then
    echo "$1"
  else
    require_default_tmplname template name required
  fi
}

deplname_from_args()
{
  require_default_deplname "not in a deployment -> use option -d to specify deployment name"
}

# $@: error message
require_default_deplname()
{
  if [ ${opts[deployment]+set} ]; then
    echo "${opts[deployment]}"
  else
    if [ -n "$DNAME" ]; then
      echo "$DNAME"
    else
      if [ -n "$CNAME" ]; then
        local a=( )
        set_array a get_component_deployments "$CNAME"
        if [ ${#a[@]} -eq 1 ]; then
          echo "${a[0]}"
        else
          if [ ${#a[@]} -eq 0 ]; then
            Error "${ERRCTX}${ERRCTX:+: }no deployment for component $CNAME"
          else
            Error "${ERRCTX}${ERRCTX:+: }multiple deployments for component $CNAME"
          fi
        fi
      else
        Error "${ERRCTX}${ERRCTX:+: }$@"
      fi
    fi
  fi
}

# $@: error message
require_default_tmplname()
{
  if [ -n "$TNAME" ]; then
    echo "$TNAME"
  else
    local d
    d="$(require_default_deplname "$@")"  
    local t="${deplTmpls["$d"]}"
    if [ -n "$t" ]; then
      echo "$t"
    else
      Error "${ERRCTX}${ERRCTX:+: }$@"
    fi
  fi
}

get_default_deplname()
{
  if [ ${opts[deployment]+set} ]; then
    echo "${opts[deployment]}"
  else
    if [ -n "$DNAME" ]; then
      echo "$DNAME"
    else
      if [ -n "$CNAME" ]; then
        local a=( )
        set_array a get_component_deployments "$CNAME"
        if [ ${#a[@]} -eq 1 ]; then
          echo "${a[0]}"
        fi
      fi
    fi
  fi
}

# $1: component name
get_component_deployments()
{
  for i in "${!deplComps[@]}"; do
    if [ "${deplComps[$i]}" == "$1" ]; then
      echo "$i"
    fi
  done
}

###########################################################################
# landscape data
###########################################################################
extensions=( )          # list of extension sources

declare -gA modDefs     # module definition locations
declare -gA deplDefs    # deployment definition locations
declare -gA deplComps   # deployment component for deployment
declare -gA deplTmpls   # deployment template for deployment
declare -gA deplActive  # active flag for deployment
declare -gA deplCommon  # commom root dir of component and deployment def
### hashed arrays (datatype provided by lib/data)
# deplCtxs    # contexts for deployments
# deplDCtxs   # descriptor contexts for deployments
# deplECtxs   # effective contexts for deployments
# deplIncls   # modules included in search path
# deplStubs   # effective stubs for deployments
# deplDStubs  # effective descriptor stubs for deployments
# deplReqs    # imports for deployments
# deplEReqs   # effective imports for deployments
# deplGlmps   # preview imports for deployments
# deplEGlmps  # effective preview imports for deployments
# deplInfos   # configuration locations for deployments
# deplImps    # list of effective imports

# hashed hashes (datatype provided by lib/data)
# deplLabels  # import label hashes
 
declare -gA tmplDefs    # deployment template locations
declare -gA tmplDone    # deployment template setup done
declare -gA tmplComps   # deployment coponent for template
declare -gA tmplTmpls   # deployment template for template

declare -gA compDefs    # component definitions
declare -gA compTypes   # component type
declare -gA compMFs     # component manifest

declare -gA pluginDefs  # plugin definitions

###########################################################################
# component API
###########################################################################

DIR_ACTIONS=actions
ACTION_CREATE_EXPORTS=create_exports
ACTION_CREATE_MANIFEST=create_manifest

# $1: name
# $2: ctx
ACTION_create_exports()
{
  {
    local s="$(get_action "$1" $ACTION_CREATE_EXPORTS)"
    if [ -n "$s"  ]; then
       _execute_action "$1" "$s" "$2"
    else
      s="$(get_action "$1" $ACTION_CREATE_MANIFEST)"
      if [ -n "$s"  ]; then
        _execute_action "$1" "$s" "$2"
      else
        cat "$2"
      fi | yaml2json | jq .exports | spiff merge - 
    fi
  } || Error "cannot create default exports for $1"
}

# $1: name
# $2: ctx
ACTION_create_manifest()
{
  local s="$(get_action "$1" $ACTION_CREATE_MANIFEST)"
  if [ -n "$s"  ]; then
    _execute_action "$1" "$s" "$2"
  else
    cat "$2"
  fi
}

########################
# action execution

# $1: deployment name
# $2: action name
# args
execute_action()
{
  local p="$(get_action "$1" "$2")"
  if [ -z "$p" ]; then
    Error "${ERRCTX}${ERRCTX:+: }action '$2' not found for '$1'"
  fi
  _execute_action "$1" "$p" "${@:3}"
}

_execute_action()
{
  local inst="$(get_instance_dir "$1")"
  local gen="$(get_instance_gen_dir "$1")"
  local state="$(get_state_dir "$1")"
  (
    export IAC_QUIET="$QUIET"
    export IAC_DEPL_STATE="$state"
    export IAC_DEPL_INST="$inst"
    export IAC_DEPL_GEN="$gen"
    export IAC_DEPL_NAME="$1"
    export IAC_DEPL_COMP_NAME="${deplComps[$1]}"
    export IAC_DEPL_COMP="${compDefs[$IAC_DEPL_COMP_NAME]}"
    export IAC_LS_ROOT="$LROOT"
    if [ "$(basename "$2")" == $ACTION_CREATE_MANIFEST ]; then
      export IAC_ACTION_CREATE_MANIFEST="$2"
    else
       export IAC_ACTION_CREATE_MANIFEST="$(get_action "$1" $ACTION_CREATE_MANIFEST)"
    fi
    mkdir -p "$state"
    debug execute: "$2" "${@:3}"
    "$2" "${@:3}"
  )
}

###########################################################################
# access
###########################################################################

get_deployment()
{
  echo "${deplDefs[$1]}"
}

get_deployment_component()
{
  local c="${deplComps[$1]}"
  if [ -n "$c" ]; then
    echo "${compDefs[$c]}"
  else
    Error "no component for $1"
  fi
}

require_deployment()
{
  local n="${1:-$DNAME}"
  if [ -z "$n" ]; then
    Error "${ERRCTX}${ERRCTX:+: }deployment name missing"
  fi
  local t="$(get_deployment "$n")"
  if [ -z "$t" ]; then
    Error "${ERRCTX}${ERRCTX:+: }deployment $n not found"
  else
    echo "$t"
  fi
}

check_deployment()
{
  local t="$(get_deployment "$1")"
  if [ -z "$t" ]; then
    return 1
  fi
  [ "${deplActive[$1]}" ]
}

get_labels()
{
  _get_hash "$1" "$2" deplLabels
}

get_imports()
{
  _get_array "$1" "$2" deplImps
}

get_glimpses()
{
  _get_array "$1" "$2" deplEGlmps
}

get_required()
{
  _get_array "$1" "$2" deplEReqs
}

get_stubs()
{
  _get_array "$1" "$2" deplStubs
}

# $1: name
# $2: action
get_action()
{
  local d="$(get_deployment "$1")"
  local c="$(get_deployment_component "$1")"
  local r="$DIR_ACTIONS/$2"
  local t="${compTypes[${deplComps[$1]}]}"

  _filter_file "$d/$r" -e || _filter_file "$c/$r" -e || _filter_plugin_file "$t" "$r" -e || true
}

get_instance_dir()
{
  local d="$LROOT/$DIR_DEPLOYMENTS/$1"
  mkdir -p "$d"
  echo "$d"
}

get_state_dir()
{
  local d="$LROOT/$DIR_STATE/$1"
  mkdir -p "$d"
  echo "$d"
}

get_instance_gen_dir()
{
  echo "$(get_instance_dir "$1")/gen"
}

get_component_dir()
{
  local c="${deplComps[$1]}"
  if [ -n "$c" ]; then
    echo "${compDefs[$c]}"
  fi
}

###########################################################################
# model
###########################################################################
DIR_STATE=state

DIR_DEPLOYMENTS=deployments
DIR_MODULES=modules
DIR_TEMPLATES=templates
DIR_COMPONENTS=components
DIR_CONFIG=config
DIR_PLUGINS=plugins

FILE_COMPONENT=component.yml
FILE_DEPLOYMENT=deployment.yml
FILE_TEMPLATE=template.yml

GEN_EXP=exp.yml
GEN_IMP=imp.yml
GEN_CTX=ctx.yml
GEN_MANIFEST=manifest.yml


norm_path()
{
  local i
  for i; do
    i="${i##$LROOT}"
    echo "${i:-/}"
  done
}

contains_dir()
{
  local d="$1"
  local i
  shift
  for i; do
    if [ -d "$d/$i" ]; then
      return 0
    fi
  done
  return 1
}

_get_path()
{
  local p=""
  local i
  for i in "${@}"; do
    p="$i/$p"
  done
  echo "${p%%/}"
}

_check_files()
{
  local i
  for i in "${@}"; do
    if [ ! -h "$i" ]; then
      if [ -f "$i" -o -d "$i" ]; then
        return 0
      fi
    fi
  done
  return 1
}

# $1: file
# $2: check
_filter_file()
{
  local f="${2:--f}"
  if [ $f "$1" ]; then
    echo "$1"
    return 0
  else
    return 1
  fi
}

# $1: type
# $2: file
# $3: check
_filter_plugin_file()
{
  if [ -n "$1" ]; then
    local m="${pluginDefs["$1"]}"
    if [ -n "$m" ]; then
      _filter_file "$m/$2" $3
      return 0
    fi
  fi
  return 1
}

#
# a stub is search from the component up to (exclusive) the
# common ancestor of the component and the deployment definition
# followed by the deployment definition up to the landscape root
#
# $1: depl name
# $2: name
lookupStub()
{
  debug "lookup stubs for $1: $2"
  local c="${deplComps[$1]}"
  local dr="$(_elemRoot "$1" "${deplDefs[$1]}")"
  if [ -n "$c" ]; then
     local d="${compDefs[$c]}"
     if [ -n "$d" ]; then
        local cr="$(_elemRoot "$c" "$d")"
        local common="${deplCommon[$1]}"
        local type="${compTypes[$c]}"
       _filter_file "$d/templates/$2" || _filter_file "$d/$2" || _filter_plugin_file "$type" "$2" || true
       _lookupTree "$c" "$2" "$d" "$common" "$DIR_CONFIG"
     fi
  fi

  lookupTemplateStubs "${deplTmpls[$1]}" "$2"
  
  _get_array a "$1" deplIncls || true
  for i in "${a[@]}"; do
    _filter_file "$i/$DIR_CONFIG/$2"
  done

  _lookupTree "$1" "$2" "${deplDefs[$1]}" "/" "$DIR_DEPLOYMENTS/$1" "$DIR_CONFIG"
}

# $1: template name
# $2: context
# $3+ ref history
lookupTemplateStubs()
{
  if [ -n "$1" ] && ! contains "$1" "${@:3}"; then
    lookupTemplateStubs "${tmplTmpls[$1]}" "$2" "$1" "${@:3}"
    local dt="${tmplDefs["$1"]}"
    if [ -n "$dt" ]; then
      _filter_file "$dt/$2" || true
    fi
  fi
}

# $1: element name
# $2: config name
# $3: start dir
lookupConfig()
{
  debug "lookup config for $1: $2"
  local dr="$1"
  _lookupTree "$1" "$2" "$3" "/" "$DIR_CONFIG"
}

_commonRoot()
{
  local parts=( )
  local t
  local names=("$@")
  local name="$1"

  while [ "$name" != "/" ]; do
    parts+=( "$name" )
    name="$(dirname "$name")";
  done

  for prefix in "${parts[@]}" /; do
    for name in "${names[@]}"; do
        if [ "${name#$prefix}" = "${name}" ]; then
           continue 2
        fi
    done
    echo "$prefix"
    break
  done
}

# $1: elem name
# $2: stub name
# $3: start dir
# $4: stop dir
# $5+ sub dirs
_lookupTree()
{
  local d="$3"
  local i
  if [ -n "$d" -a -d "$d" ]; then
    d="$(_elemRoot "$1" "$d")"
    while [ "$d" != "$LROOT" -a "$d" != "$4" ]; do
      d="$(dirname "$(dirname "$d")")"
      if [ "$d" != "$4" ]; then
        debug "lookup in $(norm_path "$d")"
         
        for i in "${@:5}"; do
          _filter_file "$d/$i/$2" || true
        done
      fi
    done
  fi
}

# $1: name
# $2: elem dir
_elemRoot()
{
  local d="$2"
  local t="$(dirname "$1")"
  while [ "$t" != . ]; do
    d="$(dirname "$d")"
    t="$(dirname "$t")"
  done
  echo "$d"
}

# $1: depl name
# $2+: name
lookupStubs()
{
  local c
  stubs=( )
  for c in "${@:2}"; do
    debug " using context $c"
    _read_list < <(lookupStub "$1" "$c")
    if [ "${#res[@]}" -eq 0 ]; then
      warn "context $c not found for $1"
    else
      debug "   found $(norm_path "${res[@]}")"
      stubs+=( "${res[@]}" )
    fi
  done
}

# $1: element name
# $2: element dir
# $3+: name
lookupConfigs()
{
  local c
  stubs=( )
  for c in "${@:3}"; do
    debug " using context $c"
    _read_list < <(lookupConfig "$1" "$c" "$2")
    if [ "${#res[@]}" -eq 0 ]; then
      warn "context $c not found for $1"
    else
      debug "   found $(norm_path "${res[@]}")"
      stubs+=( "${res[@]}" )
    fi
  done
}

scan()
{
  _scanModule "$@"
}

_scanConfigs()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  local queue=( "$1" )
  local base="$1"
  while [ "${#queue[@]}" -gt 0 ]; do
    local dir="${queue[0]}"
    local name="${dir#$base}"
    name="${name##/}"
    queue=( "${queue[@]:1}" )

    debug "scanning dir $(norm_path "$dir") ($name)"...
    for i in "$dir"/*; do
      if [ -d "$i" ]; then
        queue+=( "$i" )
      else
        p_cfg "$2  config $name${name:+/}$(basename "$i")"
      fi
    done
  done
}

_scanComponents()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  local queue=( "$1" )
  local base="$1"
  while [ "${#queue[@]}" -gt 0 ]; do
    local dir="${queue[0]}"
    local name="${dir#$base}"
    name="${name##/}"
    queue=( "${queue[@]:1}" )

    debug "scanning dir $(norm_path "$dir") ($name)"...
    if [ -n "$name" ] && _check_files "$dir/"*.yml; then
      if [ ${compDefs[$name]+set} ]; then
        log warn " ignoring duplicate component $name at $(norm_path "$dir")"
      else
        debug " found component $name at $(norm_path "$dir")"
        compDefs["$name"]="$dir"
        if [ -n "$p" ]; then
          local desc="$dir/$FILE_COMPONENT"
          if [ -f "$desc" ]; then
            type="$(readComponentType <"$desc")"
          else
            type=generic
          fi
          p_comp "$2  component $name ($type)"
        fi
      fi
    else
      for i in "$dir"/*; do
        if [ -d "$i" ]; then
          queue+=( "$i" )
        fi
      done
    fi
  done
}

_scanTemplates()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  local queue=( "$1" )
  local base="$1"
  while [ "${#queue[@]}" -gt 0 ]; do
    local dir="${queue[0]}"
    local name="${dir#$base}"
    name="${name##/}"
    queue=( "${queue[@]:1}" )

    debug "scanning dir $(norm_path "$dir") ($name)"...
    if [ -n "$name" ] && _check_files "$dir/$FILE_TEMPLATE" ; then
      if [ ${tmplDefs[$name]+set} ]; then
        log warn " ignoring duplicate deployment template $name at $(norm_path "$dir")"
      else
        debug " found deployment template $name at $(norm_path "$dir")"
        tmplDefs["$name"]="$dir"

        if [ -n "$p" ]; then
          p_tmpldef "$2  deployment template $name"
        fi
      fi
    else
      for i in "$dir"/*; do
        if [ -d "$i"  -a "$(basename "$i")" != gen ]; then
          queue+=( "$i" )
        fi
      done
    fi
  done
}

_scanDeployments()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  local queue=( "$1" )
  local base="$1"
  while [ "${#queue[@]}" -gt 0 ]; do
    local dir="${queue[0]}"
    local name="${dir#$base}"
    name="${name##/}"
    queue=( "${queue[@]:1}" )

    debug "scanning dir $(norm_path "$dir") ($name)"...
    if [ -n "$name" ] && _check_files "$dir/"*.yml "$dir/gen" ; then
      if [ ${deplDefs[$name]+set} ]; then
        if [ -f "$dir/$FILE_DEPLOYMENT" ]; then
          log warn " ignoring duplicate deployment defintion $name at $(norm_path "$dir")"
        else
          log warn " ignoring duplicate deployment config $name at $(norm_path "$dir")"
        fi
      else
        _depls["$name"]="$dir"
        if [ -f "$dir/$FILE_DEPLOYMENT" ]; then
          debug " found deployment definition $name at $(norm_path "$dir")"
          deplDefs["$name"]="$dir"

          if [ -n "$p" ]; then
            p_depldef "$2  deployment definition $name"
          fi

        else
          debug " found deployment info $name at $(norm_path "$dir")"
          if [ -n "$p" ]; then
            p_deplcfg "$2  deployment config for $name"
          fi
        fi
      fi
    else
      for i in "$dir"/*; do
        if [ -d "$i"  -a "$(basename "$i")" != gen ]; then
          queue+=( "$i" )
        fi
      done
    fi
  done
}

_scanModule()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  local m="$(basename "$1")"
  debug scanning module "$(norm_path "$1")"...
  if [ "$(basename "$(dirname "$1")")" != $DIR_MODULES ]; then
    if [ -n "$p" ]; then
      p_land "$2landscape"
    fi
  else
    if [ -n "$p" ]; then
      p_mod "$2module $m"
    fi
    if [ ${modDefs[$m]+set} ]; then
      log warn "duplicate module $m at $(norm_path "$1")"
    else
      modDefs[$m]="$1"
    fi
  fi

  if [ -d "$1/$DIR_COMPONENTS" ]; then
    _scanComponents $p "$1/$DIR_COMPONENTS" "$2"
  fi
  if [ -d "$1/$DIR_TEMPLATES" ]; then
    _scanTemplates $p "$1/$DIR_TEMPLATES" "$2"
  fi
  declare -A _depls
  if [ -d "$1/$DIR_DEPLOYMENTS" ]; then
    _scanDeployments $p "$1/$DIR_DEPLOYMENTS" "$2"
  fi
  if [ -n "$p" -a -d "$1/$DIR_CONFIG" ]; then
    _scanConfigs $p "$1/$DIR_CONFIG" "$2"
  fi
  if [ -d "$1/$DIR_MODULES" ]; then
    for i in "$1/$DIR_MODULES"/*; do
      if [ -d "$i" ]; then
         _scanModule $p "$i" "  $2"
      fi
    done
  fi
  local a=( )
  for i in "${!_depls[@]}"; do
    if [ ${deplDefs[$i]:+set} ]; then
      _get_array a "$i" deplInfos || true
      _set_array "$i" deplInfos "${a[@]}" "${_depls[$i]}"
    else
      log warn "no deployment definition for configuration $i found in $1"
    fi
  done

  scanPlugins $p "$1/$DIR_PLUGINS" "$2"
}


#
# res: result array
_read_list()
{
  local line
  res=( )
  while IFS='' read -r line; do
    res+=( "$line" )
  done
}

#
# res: result associative array
_read_hash()
{
  local line
  hash=( )
  while  read -r label value; do
    if [ -n "$label" ]; then
      hash["$label"]="$value"
    fi
  done
}

# $1: expr
# res: result array
_get_yaml_list()
{
  _read_list < <(get_yaml_field - "$1")
}

_get_yaml_labeled_list()
{
  _read_hash < <(yaml2json | jq -r $1' | if type == "object" then . as $m | keys[] | [.,$m[.]] else if type == "array" then .[] | if type == "object" then . as $m | keys[] | [.,$m[.]] else [.,.] end else empty end end | join("  ")')
}

readComponentType()
{
  local type="$(get_yaml_field - .type)"
  if [ -z "$type" ]; then
    echo generic
  else
    echo "$type"
  fi
}

# $1: comp name
setupComponent()
{
  local root="${compDefs["$1"]}"
  if [ -f "$root/$FILE_COMPONENT" ]; then
    local def="$(cat "$root/$FILE_COMPONENT")"
    local type="$(readComponentType <<<"$def")"
    compTypes[$1]="$type"
    local f="$(_filter_plugin_file "$type" "$FILE_COMPONENT" || true)"
    if [ -n "$f" ]; then
      def="$(spiff merge -- "$f" - <<<"$def" || Error "descriptor processing failed for component $1 ($type)" )"
    fi

    local res=( )
    debug " analyse context..."
    _get_yaml_list '.context[]' <<<"$def"
    debug " context ${res[@]}"
    _set_array "$1" compCtxs "${res[@]}"

    local manifest="$(get_yaml_field - .manifest <<<"$def")"
    if [ -z "$manifest" ]; then
      compMFs[$1]="$GEN_MANIFEST"
    else
      compMFs[$1]="$manifest"
    fi
  else
      compTypes[$1]=generic
    compMFs[$1]="$GEN_MANIFEST"
    _set_array "$1" compCtxs
  fi
}

# $1: element name
# $2: descriptor file
# $3: type key
# $4: type name 
# $5+: template history
# -> def
_setupElement()
{
  local a_n="$1"
  local a_d="$2"
  local a_k="$3"
  local a_t="$4"

  local ctxs=( )
  local root
  local res=( )
  local i
  declare -A hash

  eval root=\"\${${a_k}Defs[\"\$a_n\"]}\"

  debug " analyse descriptor..."
  local def="$(cat "$root/$a_d")"

  _get_yaml_list '.["descriptor-context"][]' <<<"$def"
  debug "found descriptor context: ${res[@]}"
  _set_array "$1" ${a_k}DCtxs "${res[@]}"
  if [ ${#res[@]} -gt 0 ]; then
    lookupConfigs "$a_n" "$root" "${res[@]}"
    _set_array "$a_n" ${a_k}DStubs "${stubs[@]}"
    if [ ${#stubs[@]} -gt 0 ]; then
      if [ -n "${opts[spiff]+x}" ]; then
        log info spiff merge "$root/$a_d" "${stubs[@]}"
      fi
      def="$(spiff merge - "${stubs[@]}" <<<"$def" || Error "descriptor processing for $1 failed")"
    fi
  else
    _set_array "$a_n" ${a_k}DStubs
  fi

  declare -A implabels=( )

  local rlabels=( )
  local glabels=( )

  local comp="$(get_yaml_field - .component <<<"$def")"
  local tmpl="$(get_yaml_field - .template <<<"$def")"
  if [ -z "$comp" ]; then
    if [ -z "$tmpl" ]; then
      log warn " no component or template defined for $a_t $a_n"
    else
      local troot="${tmplDefs["$tmpl"]}"
      if [ -z "$troot" ]; then
        log warn " template $tmpl for $a_t $a_n not defined"
      else
        _setupTemplate "$tmpl" "${@:5}" 
        debug " using template $tmpl"
        eval "${a_k}Tmpls[\"\$a_n\"]=\"\$tmpl\""
        comp="${tmplComps["$tmpl"]}"
        if [ -z "$comp" ]; then
          log warn " no component defined for $a_t $a_n because template $tmpl defines no component"
        fi
        debug " refering to component $comp"
        _get_hash implabels "$tmpl" tmplLabels
        _get_array rlabels "$tmpl" tmplRLab
        _get_array glabels "$tmpl" tmplGLab
        _get_array ctxs "$tmpl" tmplECtxs
        debug " template contexts: ${ctxs[@]}"
      fi
    fi
  else
    if [ -n "$tmpl" ]; then
      log warn " ignoring template for $a_t $a_n because it alreday defines a component"
    fi
    debug " using component $comp"
    _get_array ctxs "$comp" compCtxs
    debug " component contexts: ${ctxs[@]}"
  fi

  local croot
  if [ -n "$comp" ]; then
    croot="${compDefs["$comp"]}"
    if [ -z "$croot" ]; then
      log warn " component $comp for $a_t $a_n not defined"
    fi
  fi
  eval "${a_k}Comps[\"\$a_n\"]=\"\$comp\""

  debug " analyse imports..."

  declare -A found
  _get_yaml_labeled_list '.requires' <<<"$def"
  for i in "${!hash[@]}"; do
    local d="${hash["$i"]}"
    local l="$(_map_name "$i")"
    found["$l"]="$d"
    implabels["$l"]="$d"
    if ! contains "$l" "${rlabels[@]}"; then
      rlabels+=( "$l" )
    fi
  done
  debug " requires ${found[@]}"
  _set_array "$a_n" ${a_k}Reqs "${found[@]}"
  
  res=( )
  for i in "${rlabels[@]}"; do
    local d="${implabels["$i"]}"
    if ! contains "$d" "${res[@]}"; then
      res+=( "$d" )
    fi
  done
  debug " requires (effective) ${res[@]}"
  _set_array "$a_n" ${a_k}EReqs "${res[@]}"

  debug " analyse glimpses..."
  found=( )
  _get_yaml_labeled_list '.glimpses' <<<"$def"
  for i in "${!hash[@]}"; do
    local d="${hash["$i"]}"
    local l="$(_map_name "$i")"
    if ! contains "$l" "${rlabels[@]}"; then
      if ! contains "$l" "${glabels[@]}"; then
        glabels+=( "$l" )
      fi
      implabels["$l"]="$d"
      found["$l"]="$d"
    else
      if [ ${found["$l"]+set} ]; then
        warn "ignoring label '$l': already defined for $a_t $a_n"
      fi
    fi
  done
  debug " glimpses ${found[@]}"
  _set_array "$a_n" ${3}Glmps "${found[@]}"

  local filtered=( )
  for i in "${glabels[@]}"; do
    local d="${implabels["$i"]}"
    if ! contains "$d" "${filtered[@]}"; then
      filtered+=( "$d" )
      if ! contains "$d" "${res[@]}"; then
        res+=( "$d" )
      fi
    fi
  done
  debug " glimpses ${filtered[@]}"
  _set_array "$a_n" ${3}EGlmps "${filtered[@]}"

  debug " imports ${res[@]}"
  _set_array "$a_n" ${3}Imps "${res[@]}"
  _set_array "$a_n" ${3}RLab "${rlabels[@]}"
  _set_array "$a_n" ${3}GLab "${glabels[@]}"
  _set_hash "$a_n" ${3}Labels implabels

  debug " analyse includes..."
  _get_yaml_list '.includes[]' <<<"$def"
  debug " includes ${res[@]}"
  _set_array "$a_n" ${a_k}Incls "${res[@]}"
  for i in "${res[@]}"; do
    local m="${modDefs[$i]}"
    if [ -z "$m" ]; then
      log warn " module $i for $a_t $a_n not defined"
    fi
  done

  debug " analyse context..."
  _get_yaml_list '.context[]' <<<"$def"
  debug " context ${res[@]}"
  _set_array "$a_n" ${a_k}Ctxs "${res[@]}"

  set_array res uniq "${ctxs[@]}" "${res[@]}"
  debug " effective context ${res[@]}"
  _set_array "$a_n" ${3}ECtxs "${res[@]}"

  _handleSetup_$a_k
}

_handleSetup_tmpl()
{
  true
}

# $1: name
setupTemplate()
{
  _setupTemplate "$1"
}

# $1: name
# $2+: history
_setupTemplate()
{
  if contains "$@"; then
    Error "deployment template cycle for $1: ${*:2}"
  fi
  if [ -n "${tmplDone["$1"]}" ]; then
    return
  fi
  tmplDone["$1"]=X

  _setupElement "$1" $FILE_TEMPLATE tmpl "deployment template" "$@"
}

# $1: depl name
setupDeployment()
{
  _setupElement "$1" $FILE_DEPLOYMENT depl "deployment definition"
}

_handleSetup_depl()
{
  local active="$(get_yaml_field - .active <<<"$def")"
  if [ -z "$active" -o "$active" == true ]; then
    active=X
  else 
    active=
  fi

  deplActive["$a_n"]="$active"
  if [ -n "$croot" ]; then
    deplCommon["$a_n"]="$(_commonRoot "$croot" "$root")"
  else
    deplCommon["$a_n"]=""
  fi
  local stubs=( )
  lookupStubs "$a_n"  "${res[@]}"
  _set_array "$a_n" deplStubs "${stubs[@]}"
}


_check_for_hierarchy()
{
  local d
  for d in "$@"; do
    if [ -d "$d" ]; then
      for d in "$d"/*.yml; do
        if [ -f "$d" ]; then
          continue 2
        fi
      done
      return 
    fi
  done
  return 1
}

_setupEnv()
{
  local d=$(pwd)
  local names=( )
  local r
  local l
  local n
  
  DROOT=
  DNAME=
  TROOT=
  TNAME=
  CROOT=
  CNAME=
  MROOT=
  MNAME=

  if _check_for_hierarchy "$d/$DIR_DEPLOYMENTS" \
                          "$d/$DIR_COMPONENTS"  \
                          "$d/$DIR_TEMPLATES"  \
                          "$d/$DIR_PLUGINS"  \
                          "$d/$DIR_MODULES"; then
    MROOT="$d" 
  fi
  while [ -z "$MROOT" -a "$d" != "/" ]; do
    n="$(basename "$d")"
    p="$(dirname "$d")"
    if _check_files "$d"/*.yml "$d/gen"; then
      r="$d"
    fi
    case "$n" in
      $DIR_DEPLOYMENTS) 
        if [ -n "$r" ]; then
          DNAME="$(_get_path "${names[@]}")"
          DROOT="$d/$DNAME"
          log found "Found deployment $DNAME at $DROOT"
        fi
        names=( )
        MROOT="$p";;
      $DIR_COMPONENTS) 
        if [ -n "$r" ]; then
          CNAME="$(_get_path "${names[@]}")"
          CROOT="$d/$CNAME"
          log found "Found component $CNAME at $CROOT"
        fi
        names=( )
        MROOT="$p";;
      $DIR_TEMPLATES) 
        if [ -n "$r" ]; then
          TNAME="$(_get_path "${names[@]}")"
          TROOT="$d/$TNAME"
          log found "Found template $TNAME at $TROOT"
        fi
        names=( )
        MROOT="$p";;
      $DIR_MODULES) 
        if [ -n "$l" ]; then
          MNAME="$l"
          MROOT="$d/$l"
          log found "Found module $l"
        else
          MROOT="$(dirname "$d")" 
        fi
        names=( );;
      *)
        l="$n"
        names+=( "$n" )
    esac
    d="$p"
  done

  if [ -n "$MROOT" ]; then
    log found "Found module at $MROOT"
    LROOT="$MROOT"
    while [ "$(basename "$(dirname "$LROOT")")" == $DIR_MODULES ]; do
      if [ -z "$MNAME" ]; then
        MNAME="$(basename "$LROOT")"
      fi
      LROOT="$(dirname "$(dirname "$LROOT")")"
    done
    log found "Found landscape root at $LROOT"
  else
    return 1
  fi
}

setupEnv()
{
  if ! _setupEnv; then
    Error "no module or landscape found"
  fi
}

# $1: type
# $2+: names
setupType()
{
  local e
  if [ $# -gt 1 ]; then
    debug "*** ${1}s: ${@:2}"
    for e in "${@:2}"; do
      debug "* setup $e"
      setup${1^} "$e"
    done
  fi
}

cacheAll()
{
  log info caching landscape...
  scanPlugins "$IAC_PLUGINS"
  scan "$LROOT"

  setupType component "${!compDefs[@]}"
  setupType template "${!tmplDefs[@]}"
  setupType deployment "${!deplDefs[@]}"
}

scanPlugins()
{
  local p
  local i
  if [ "$1" == -p ]; then
    p=$1
    shift
  fi
  for i in "$1"/*; do
    if [ -d "$i" ]; then
      if [ -n "$p" ]; then
        if [ -d "$i/actions" ]; then
          p_plugin "  $2component type $(basename "$i")"
        else
          p_plugin "  $2plugin $(basename "$i")"
        fi
      fi
      pluginDefs["$(basename "$i")"]="$i"
      scanExtensions "$i"
    fi
  done
}

scanExtensions()
{
  local e
  debug scanning for extensions: "$1"
  if [ -d "$1/iac" ]; then
    for e in "$1/iac"/*; do
      if [ -f "$e" ]; then
        extensions+=( "$e" )
        if [ -n "$p" ]; then
          p_plugin "  $2extension $(basename "$1")#$(basename "$e")"
        fi
      fi
    done
  fi
}

loadExtensions()
{
  local e
  for e in "${extensions[@]}"; do
    debug loading "$e"
    source "$e"
  done
}

# $1: name
cleanup_deployment()
{
  local gen="$(get_instance_gen_dir "$d")"
  if [ -d "$gen" ]; then
    info "cleanup $d"
    rm -Rf "$gen"
  fi
}

###########################################################################
# generate
###########################################################################

_map_name()
{
  tr '/' '_' <<<"$1"
}

# $1: name
# $2: gen dir
_generate_imports()
{
  local l
  local i
  local a
  local t
  declare -A labels
  declare -A imps

  t="$(require_deployment "$1")"

  if [ ! ${deplActive[$1]:+set} ]; then
    Error "deployment $1 is inactive"
  fi
  mkdir -p "$2/$1"
  {
    local c="${deplComps["$1"]}"
    echo "imports:"
    echo "  meta:"
    echo "    component:"
    echo "      name: \"$c\""
    echo "      dir: \"${compDefs["$c"]}\""
    echo "    deployment:"
    echo "      name: \"$1\""
    echo "      dir: \"$(get_instance_dir "$1")\""
    echo "      state: \"$(get_state_dir "$1")\""
    get_labels labels "$1"
    for l in "${!labels[@]}"; do
      i="${labels["$l"]}"
      if [ -f "$2/$i/$GEN_EXP" ]; then
        echo "  # import of deployment $i"
        echo "  $l: $(yaml2json <"$2/$i/$GEN_EXP")"
        if [ ${imps["$i"]:-unset} ]; then
          log title "    imp $i: $(md5sum "$2/$i/$GEN_EXP")"
          imps["$i"]=X
        fi
      else
        log warn "    no import for $i"
      fi
    done 
  } >"$2/$1/$GEN_IMP"
}

# $1: name
# $2: gen dir
_generate_context()
{
  _generate_imports "$@"
  #confirm "$(cat "$2/$1/$GEN_IMP")"
  __generate_context "$1" "$2/$1"
}

# $1: deployment name
# $2: gen dir
__generate_context()
{
  local stubs=( )
  get_stubs stubs "$1"

  local ctx="$2/$GEN_CTX"
  if [ -n "${opts[spiff]+x}" ]; then
    log info spiff merge "${stubs[@]}" "$2/$GEN_IMP" 
  fi
  spiff merge "${stubs[@]}" "$2/$GEN_IMP" >"$ctx" || Error "cannot generate context for $1"
}

# $1: name
# $2: tmp gen dir
_generate_exports()
{
  _generate_context "$@"
  local ctx="$2/$1/$GEN_CTX"
  ACTION_create_exports "$1" "$ctx" >"$2/$1/$GEN_EXP"
  log confirm "    exp: $(md5sum "$2/$1/$GEN_EXP")"
}

# $1: name
# $2: deployments gen dir
__generate_exports()
{
  __generate_context "$@"
  local ctx="$2/$GEN_CTX"
  ACTION_create_exports "$1" "$ctx" >"$2/$GEN_EXP"
  log confirm "    exp: $(md5sum "$2/$GEN_EXP")"
}

import_closure()
{
  local __omit=X
  local __req
  _closure "$@"
}

deploy_order()
{
  local __omit 
  local __req
  if [ $# -eq 2 ]; then
    __req=X
    _closure "$@"
  else 
    local _list=( ) 
    local d
    for d in "${!deplDefs[@]}"; do
      if [ "${deplActive[$d]}" ]; then
        _list+=( "$d" )
      fi
    done
    info "deployments: ${_list[@]}"
    _closure "$1" "${_list[@]}"
  fi
}

# $1: array name
# $2; name
_closure()
{
  local __closure=( )
  local __stack=( )
  local __queue=( "${@:2}" )

  declare -A __required
  __missing=( )
  while [ ${#__queue[@]} -gt 0 ]; do
    local next="${__queue[0]}"
    __queue=( "${__queue[@]:1}" )
    if ! contains "$next" "${__closure[@]}"; then
      __closure "$next" $__omit
      if [ -n "$__req" ]; then
        __queue=( )
      fi
    fi
    __omit=
  done
  eval "$1=( \"\${__closure[@]}\" )"
}

# $1: name
# [$2]: exclude flag
__closure()
{
  local _imps=( )
  local i
  if ! check_deployment "$1"; then
    local m
    if [ "${deplComps[$1]}" ]; then
      m="inactive '$1'"
    else
      m="missing '$1'"
    fi
    __missing+=( "$m ${__required[$n]}" )
    debug "$m"
  else
    if [ -z "$2" ]; then
      __stack=( "$1" "${__stack[@]}" )
    fi
    get_required _imps "$1"
    debug "processing deps $1: ${_imps[@]}"
    for i in "${_imps[@]}"; do
      if ! contains "$i" "${__stack[@]}" "${__closure[@]}"; then
        __required["$i"]="required by '$1' ${__required[$1]}"
        __closure "$i"
      fi
    done
    get_glimpses _imps "$1"
    debug "processing glimpses $1: ${_imps[@]}"
    for i in "${_imps[@]}"; do
      if ! contains "$i" "${__stack[@]}" "${__closure[@]}" "${__queue[@]}"; then
        __required["$i"]="glimpsed by '$1' ${__required[$1]}"
        __queue+=( "$i" )
      fi
    done
    if [ -z "$2" ]; then
      __closure+=( "$1" )
      __stack=( "${__stack[@]:1}" )
    fi
  fi
}

# $1; relation
# $2; name
# [$3#]: closure
has_cycle()
{
  if contains "${@:2}"; then
    return 0
  else
    local i
    local imps=( )
    get_$1 imps "$2"
    for i in "${imps[@]}"; do
      if has_cycle "$1" "$i" "$@"; then
        return 0
      fi
    done
  fi
  return 1
}

# $1: tmp
# $2+: list
_generate_list()
{
  local old
  local new
  local i

  mod=
  for i in ${@:2}; do
    log info "  generate $i"
    if [ -f "$1/$i/$GEN_EXP" ]; then
      old="$(cat "$1/$i/$GEN_EXP")"
      _generate_exports $i "$1"
      if [ "$old" != "$(cat "$1/$i/$GEN_EXP")" ]; then
        log hint "    $i has changed -> regenerate cycle"
        mod=X
      fi
    else
      _generate_exports $i "$1"
    fi
  done
}

declare -A temp

# $1: deployment name
# $2: generation base
_publish()
{
  local gen="$(get_instance_gen_dir "$1")"
  mkdir -p "$gen"
  mv "$2/$1"/* "$gen"
}


# $1: deployment name
# $2: generation base
# $3: publish function
_handlePublish()
{
  if [ ${opts[all]+set} ]; then
    local i
    for i in "${imps[@]}"; do
      $3 "$i" "$2"
    done
  else
    $3 "$1" "$2"
  fi
}

# $1: deployment name
# $2: tmp dir
# [$3]: X= inculde  initial
_generate_closure()
{
  imps=( )
  if ! import_closure imps "$1"; then
    list_array __missing dumpargs_err
    return 1
  fi
  log info "dependencies for $1: ${imps[@]}"
  if [ -n "$3" ] && ! contains "$1" "${imps[@]}"; then
    imps+=( "$1" )
  fi
  _generate_list "$2" "${imps[@]}"
  if has_cycle imports "$1"; then
    log hint "  cycle detected"
    local mod=X
    while [ -n "$mod" ]; do
      log info "regenerate cycle"
      _generate_list "$2" "${imps[@]}"
    done
  fi
}

# $1: name
# $2; dir
generate_imports()
{
  local imps=( )
  _generate_closure "$@"
  if ! contains "$1" "${imps[@]}"; then
    log info "generating imports for $1"
    _generate_imports "$@"
  fi

  _handlePublish "$1" "$2" _publish
}

# $1: name
# $2: dir
# [$3:] publish function
generate_context()
{
  local publish="${3:-_publish}"
  local imps=( )
  _generate_closure "$1" "$2"
  if ! contains "$1" "${imps[@]}"; then
    log info "generating context for $1"
    _generate_context "$@"
  fi

  _handlePublish "$1" "$2" $publish
}

# $1: name
# $2; dir
generate_exports()
{
  local imps=( )
  _generate_closure "$@" X

  _handlePublish "$1" "$2" _publish
}

#
# $1: deployment name
# $2: generation base dir
#
_publishManifest()
{
  local manifest="${compMFs[${deplComps[$1]}]}"
  log info "generating manifest for $1 ($manifest)"
  local gen="$(get_instance_gen_dir "$1")"
  if [ -f "$2/$1/$manifest" ]; then
    _publish "$@"
  else
    _publish "$@"
    ACTION_create_manifest "$1" "$gen/$GEN_CTX" > "$gen/$manifest"
  fi
}

generate_manifest()
{
  if [ "$#" -ne 2 ]; then
    Error "invalid call of 'generate_manifest': too many args ($#)"
  fi
  generate_context "$@" _publishManifest
}

__generate_manifest()
{
  if [ "$#" -ne 2 ]; then
    Error "invalid call of 'generate_manifest': too many args ($#)"
  fi
  __generate_context "$@"
  local manifest="${compMFs[${deplComps[$1]}]}"
  ACTION_create_manifest "$1" "$2/$GEN_CTX" > "$2/$manifest"
}
